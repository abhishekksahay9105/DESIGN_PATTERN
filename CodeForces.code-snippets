{
    // Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
    // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
    // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
    // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
    // Placeholders with the same ids are connected.
    // Example:
    "codeforces": {
        "prefix": "codeforecs",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "int mod = 1e9 + 7;",
            "",
            "void solve ()",
            "{",
            "    int n;",
            "    cin >> n;",
            "}",
            "",
            "int main ()",
            "{",
            "    int t;",
            "    cin >> t;",
            "",
            "    while (t--)",
            "    {",
            "        solve ();",
            "    }",
            "",
            "    return 0;",
            "}"
        ]
    },

    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "const int INF = std::numeric_limits<int>::max ();",
            "",
            "// Graph should be weighted",
            "// Directed or undirected",
            "// Non-negative edge weights",
            "// if disconnected run separately",
            "// Single source to all destinations",
            "",
            "void dijkstra (std::vector<std::vector<std::pair<int, int>>>& graph, int source, std::vector<int>& distances)",
            "{",
            "    int numVertices = graph.size ();",
            "    distances.resize (numVertices, INF);",
            "    distances[source] = 0;",
            "",
            "    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;",
            "    pq.push ({ 0, source });",
            "",
            "    while (!pq.empty ())",
            "    {",
            "        int u = pq.top ().second;",
            "        int distU = pq.top ().first;",
            "        pq.pop ();",
            "",
            "        if (distU > distances[u])",
            "        {",
            "            continue;",
            "        }",
            "",
            "        for (const auto& neighbor : graph[u])",
            "        {",
            "            int v = neighbor.first;",
            "            int weight = neighbor.second;",
            "            int newDist = distances[u] + weight;",
            "",
            "            if (newDist < distances[v])",
            "            {",
            "                distances[v] = newDist;",
            "                pq.push ({ newDist, v });",
            "            }",
            "        }",
            "    }",
            "}"
        ]
    },

    "Bellman-Ford":{
        "prefix": "Bellman-Ford",
        "body": [
            "const int INF = std::numeric_limits<int>::max ();",
            "",
            "// Bellman-Ford Algorithm function",
            "// Negative edge weights are allowed",
            "// Any connectivity",
            "// Single source vertex to all other vertices",
            "// Assumes that there are no negative cycles reachable from the source vertex. not corret result",
            "// Handle negative cycles in a graph",
            "",
            "void bellmanFord (std::vector<std::tuple<int, int, int>>& edges, int numVertices, int source, std::vector<int>& distances)",
            "{",
            "    distances.resize (numVertices, INF);",
            "    distances[source] = 0;",
            "",
            "    // Relax edges repeatedly (V - 1) times",
            "    for (int i = 0; i < numVertices - 1; ++i)",
            "    {",
            "        for (const auto& edge : edges)",
            "        {",
            "            int u, v, weight;",
            "            std::tie (u, v, weight) = edge;",
            "",
            "            if (distances[u] != INF && distances[u] + weight < distances[v])",
            "            {",
            "                distances[v] = distances[u] + weight;",
            "            }",
            "        }",
            "    }",
            "",
            "    // Check for negative cycles",
            "    for (const auto& edge : edges)",
            "    {",
            "        int u, v, weight;",
            "        std::tie (u, v, weight) = edge;",
            "",
            "        if (distances[u] != INF && distances[u] + weight < distances[v])",
            "        {",
            "            std::cout << \"Graph contains a negative cycle!\" << std::endl;",
            "        }",
            "    }",
            "",
            "}",
        ]
    }

    "floydWarshall":{
        "prefix": "floydWarshall",
        "body": [
            "const int INF = std::numeric_limits<int>::max (); // Infinity value for initialization",
            "",
            "// Graph should be weighted",
            "// directed or undirected",
            "// Non-negative edge weights (for undirected graphs)",
            "// assumes that the graph does not contain any negative cycles",
            "// Any connectivity",
            "",
            "// Floyd-Warshall Algorithm function",
            "void floydWarshall (std::vector<std::vector<int>>& graph)",
            "{",
            "    int numVertices = graph.size ();",
            "",
            "    // Initialize the distance matrix with the graph's weights",
            "    std::vector<std::vector<int>> distances (graph);",
            "",
            "    // Calculate shortest distances between all pairs of vertices",
            "    for (int k = 0; k < numVertices; ++k)",
            "    {",
            "        for (int i = 0; i < numVertices; ++i)",
            "        {",
            "            for (int j = 0; j < numVertices; ++j)",
            "            {",
            "                // If vertex k is on the shortest path from i to j, update the distance",
            "                if (distances[i][k] != INF && distances[k][j] != INF && distances[i][k] + distances[k][j] < distances[i][j])",
            "                {",
            "                    distances[i][j] = distances[i][k] + distances[k][j];",
            "                }",
            "            }",
            "        }",
            "    }",
            "}",
        ]
    },

    "topologicalSort":{
        "prefix": "topologicalSort",
        "body": [
            "// The graph should be directed & acyclic",
            "// Graph should be connected Strongly or weakly",
            "",
            "",
            "// Function to perform topological sorting using Kahn's algorithm",
            "std::vector<int> topologicalSort (const std::vector<std::vector<int>>& graph, int numVertices)",
            "{",
            "    std::vector<int> inDegree (numVertices, 0);",
            "    std::vector<int> topologicalOrder;",
            "",
            "    // Calculate in-degree for each vertex",
            "    for (int u = 0; u < numVertices; ++u)",
            "    {",
            "        for (int v : graph[u])",
            "        {",
            "            inDegree[v]++;",
            "        }",
            "    }",
            "",
            "    // Create a queue and enqueue vertices with in-degree 0",
            "    std::queue<int> q;",
            "    for (int u = 0; u < numVertices; ++u)",
            "    {",
            "        if (inDegree[u] == 0)",
            "        {",
            "            q.push (u);",
            "        }",
            "    }",
            "",
            "    // Process vertices in the queue",
            "    while (!q.empty ())",
            "    {",
            "        int u = q.front ();",
            "        q.pop ();",
            "        topologicalOrder.push_back (u);",
            "",
            "        // Reduce in-degree of adjacent vertices",
            "        for (int v : graph[u])",
            "        {",
            "            inDegree[v]--;",
            "            if (inDegree[v] == 0)",
            "            {",
            "                q.push (v);",
            "            }",
            "        }",
            "    }",
            "",
            "    // Check if all vertices are included in the topological order",
            "    if (topologicalOrder.size () != numVertices)",
            "    {",
            "        std::cout << \"The graph contains a cycle. Topological sorting is not possible.\" << std::endl;",
            "        return {};",
            "    }",
            "",
            "    return topologicalOrder;",
            "}",
        ]  
    },

    "prims":{
        "prefix": "prims",
        "body": [
            "typedef std::pair<int, int> pii; // pair of (weight, vertex)",
            "",
            "// The graph must be undirected",
            "// The graph must be connected",
            "// The graph must be weighted",
            "",
            "std::vector<pii> prims (std::vector<std::vector<pii>>& graph)",
            "{",
            "    int num_vertices = graph.size ();",
            "    int start_vertex = 0;",
            "",
            "    std::unordered_set<int> visited;",
            "    std::vector<pii> minimum_spanning_tree;",
            "    std::priority_queue<pii, std::vector<pii>, std::greater<pii>> priority_queue;",
            "",
            "    priority_queue.push ({ 0, start_vertex });",
            "",
            "    while (!priority_queue.empty ())",
            "    {",
            "        int weight = priority_queue.top ().first;",
            "        int current_vertex = priority_queue.top ().second;",
            "        priority_queue.pop ();",
            "",
            "        if (visited.find (current_vertex) == visited.end ())",
            "        {",
            "            visited.insert (current_vertex);",
            "            minimum_spanning_tree.push_back ({ weight, current_vertex });",
            "",
            "            for (const auto& neighbor : graph[current_vertex])",
            "            {",
            "                int neighbor_vertex = neighbor.second;",
            "                int edge_weight = neighbor.first;",
            "",
            "                if (visited.find (neighbor_vertex) == visited.end ())",
            "                {",
            "                    priority_queue.push ({ edge_weight, neighbor_vertex });",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    return minimum_spanning_tree;",
            "}",
        ]
    },

    "UnionFind":{
        "prefix": "UnionFind",
        "body": [
            "class UnionFind",
            "{",
            "   private:",
            "       std::vector<int> parent;",
            "       std::vector<int> rank;",
            "   ",
            "   public:",
            "       void UnionFind (int n)",
            "       {",
            "           parent.resize (n);",
            "           rank.resize (n, 0);",
            "           for (int i = 0; i < n; ++i)",
            "           {",
            "               parent[i] = i;",
            "           }",
            "       }",
            "   ",
            "       int find (int x)",
            "       {",
            "           if (x != parent[x])",
            "           {",
            "               return parent[x] = find (parent[x]);",
            "           }",
            "           return parent[x];",
            "       }",
            "   ",
            "       void unionSets (int x, int y)",
            "       {",
            "           int rootX = find (x);",
            "           int rootY = find (y);",
            "   ",
            "           if (rootX != rootY)",
            "           {",
            "               if (rank[rootX] < rank[rootY])",
            "               {",
            "                   parent[rootX] = rootY;",
            "               }",
            "               else if (rank[rootX] > rank[rootY])",
            "               {",
            "                   parent[rootY] = rootX;",
            "               }",
            "               else",
            "               {",
            "                   parent[rootY] = rootX;",
            "                   rank[rootX]++;",
            "               }",
            "           }",
            "      }",
            "}",

        ]
    }
}
